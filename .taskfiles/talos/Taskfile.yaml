---
version: '3'

vars:
  SYSTEM_UPGRADE_KS: '{{.KUBERNETES_DIR}}/apps/system-upgrade/system-upgrade-controller/ks.yaml'

env:
  KUBERNETES_VERSION:
    sh: yq '.spec.postBuild.substitute.KUBERNETES_VERSION | select(.)' {{.SYSTEM_UPGRADE_KS}}
  TALOS_VERSION:
    sh: yq '.spec.postBuild.substitute.TALOS_VERSION | select(.)' {{.SYSTEM_UPGRADE_KS}}

tasks:

  list-node-types:
    desc: List all available node types
    dir: talos
    cmds:
      - |
        echo "Available node types:"
        find node-types -maxdepth 1 -type d -not -path node-types | sed 's|node-types/||' | sort
    silent: true

  list-nodes:
    desc: List all nodes and their types
    dir: talos
    cmds:
      - |
        echo "Node mappings:"
        yq '.nodes | to_entries | .[] | .key + " -> " + .value' node-mapping.yaml
    preconditions:
      - test -f {{.TALOS_DIR}}/node-mapping.yaml
      - which yq
    silent: true

  regenerate-schematic:
    desc: Regenerate schematic ID for a node type [NODE_TYPE=required]
    dir: talos
    requires:
      vars: [NODE_TYPE]
    cmds:
      - |
        echo "Regenerating schematic for {{.NODE_TYPE}}..."
        SCHEMATIC_ID=$(talosctl image factory schematic --output-path node-types/{{.NODE_TYPE}}/schematic.yaml)
        echo "New schematic ID: $SCHEMATIC_ID"
        echo "You may need to update TALOS_SCHEMATIC in your environment"
    preconditions:
      - test -f {{.TALOS_DIR}}/node-types/{{.NODE_TYPE}}/schematic.yaml
      - which talosctl

  add-node-type:
    desc: Add a new node type [NODE_TYPE=required] [TEMPLATE_SOURCE=optional]
    dir: talos
    requires:
      vars: [NODE_TYPE]
    vars:
      TEMPLATE_SOURCE: '{{.TEMPLATE_SOURCE | default "upstream.j2"}}'
    cmds:
      - |
        echo "Creating new node type: {{.NODE_TYPE}}"
        mkdir -p node-types/{{.NODE_TYPE}}/controlplane
        cp {{.TEMPLATE_SOURCE}} node-types/{{.NODE_TYPE}}/template.j2
        cp schematic.yaml node-types/{{.NODE_TYPE}}/schematic.yaml
        echo "Node type {{.NODE_TYPE}} created!"
        echo "Next steps:"
        echo "1. Edit node-types/{{.NODE_TYPE}}/template.j2 for hardware-specific config"
        echo "2. Edit node-types/{{.NODE_TYPE}}/schematic.yaml for required extensions"
        echo "3. Add node IP mappings to node-mapping.yaml"
        echo "4. Put controlplane configs in node-types/{{.NODE_TYPE}}/controlplane/"
    preconditions:
      - test ! -d {{.TALOS_DIR}}/node-types/{{.NODE_TYPE}}
      - test -f {{.TALOS_DIR}}/{{.TEMPLATE_SOURCE}}

  generate-config:
    desc: Generate talosconfig from secrets bundle
    dir: talos
    cmds:
      - talosctl gen config --with-secrets {{.ROOT_DIR}}/secrets.yaml --output-types talosconfig -o talosconfig --force homeops {{.CONTROL_PLANE_ENDPOINT}}
      - talosctl config endpoint {{.TALOS_ENDPOINTS}}
      - talosctl config nodes {{.TALOS_NODES}}
    sources:
      - "{{.ROOT_DIR}}/secrets.yaml"
    generates:
      - talosconfig
    preconditions:
      - test -f {{.ROOT_DIR}}/secrets.yaml
      - which talosctl

  apply-node:
    desc: Apply a new configuration to a node [NODE=required]
    dir: talos
    requires:
      vars: [NODE]
    env:
      CONTROL_PLANE_ENDPOINT: "{{.CONTROL_PLANE_ENDPOINT}}"
    vars:
      NODE_TYPE:
        sh: yq '.nodes["{{.NODE}}"]' node-mapping.yaml
      TALOS_SCHEMATIC:
        sh: talosctl image factory schematic --output-path node-types/{{.NODE_TYPE}}/schematic.yaml
    cmds:
      - |
        echo "Applying configuration to node {{.NODE}} ({{.NODE_TYPE}})"
        mise exec -- talosctl apply-config \
          --insecure \
          --nodes "{{.NODE}}" \
          --file <( \
            minijinja-cli \
              --format yaml \
              --env \
              -D "NODE={{.NODE}}" \
              -D "TALOS_SCHEMATIC={{.TALOS_SCHEMATIC}}" \
              node-types/{{.NODE_TYPE}}/template.j2 > /tmp/base-config.yaml && \
            yq eval-all 'select(fileIndex == 0) * select(fileIndex == 1)' \
              /tmp/base-config.yaml node-types/{{.NODE_TYPE}}/controlplane/{{.NODE}}.yaml | \
            op inject
          )
    preconditions:
      - op user get --me
      - test -f {{.TALOS_DIR}}/node-mapping.yaml
      - test -f {{.TALOS_DIR}}/node-types/{{.NODE_TYPE}}/template.j2
      - test -f {{.TALOS_DIR}}/node-types/{{.NODE_TYPE}}/controlplane/{{.NODE}}.yaml
      - test -f {{.TALOS_DIR}}/node-types/{{.NODE_TYPE}}/schematic.yaml
      - test -f {{.TALOS_DIR}}/talosconfig
      - which minijinja-cli op talosctl yq

  upgrade-node:
    desc: Upgrade Talos on a single node [NODE=required]
    cmd: talosctl --nodes {{.NODE}} upgrade --image={{.TALOS_IMAGE}} --timeout=10m
    vars:
      MACHINE_TYPE:
        sh: talosctl --nodes {{.NODE}} get machinetypes --output=jsonpath='{.spec}'
      TALOS_IMAGE:
        sh: |-
          talosctl --nodes {{.NODE}} get machineconfig --output=jsonpath='{.spec}' \
            | yq '.machine.install.image | select(. != null)'
    requires:
      vars: [NODE]
    preconditions:
      - talosctl config info
      - talosctl --nodes {{.NODE}} get machineconfig
      - which minijinja-cli talosctl yq

  upgrade-k8s:
    desc: Upgrade Kubernetes across the whole cluster
    cmd: talosctl --nodes {{.RANDOM_CONTROLLER}} upgrade-k8s --to $KUBERNETES_VERSION
    vars:
      RANDOM_CONTROLLER:
        sh: talosctl config info --output json | jq --raw-output '.endpoints[]' | sort -R | head -1
    preconditions:
      - talosctl config info
      - talosctl --nodes {{.RANDOM_CONTROLLER}} get machineconfig
      - which jq talosctl

  reboot-node:
    desc: Reboot Talos on a single node [NODE=required] [MODE=default]
    cmd: talosctl --nodes {{.NODE}} reboot --mode={{.MODE}}
    vars:
      MODE: '{{.MODE | default "default"}}'
    requires:
      vars: [NODE]
    preconditions:
      - talosctl config info
      - talosctl --nodes {{.NODE}} get machineconfig
      - which talosctl

  shutdown-cluster:
    desc: Shutdown Talos across the whole cluster
    prompt: Shutdown the Talos cluster ... continue?
    cmd: talosctl --nodes {{.NODES}} shutdown --force
    vars:
      NODES:
        sh: talosctl config info --output json | jq --join-output '[.nodes[]] | join(",")'
    preconditions:
      - talosctl config info
      - talosctl --nodes {{.NODES}} get machineconfig
      - which jq talosctl

  reset-node:
    desc: Reset Talos on a single node [NODE=required]
    prompt: Reset Talos node '{{.NODE}}' ... continue?
    cmd: talosctl --nodes {{.NODE}} reset --graceful=false
    requires:
      vars: [NODE]
    preconditions:
      - talosctl config info
      - talosctl --nodes {{.NODE}} get machineconfig
      - which talosctl

  reset-cluster:
    desc: Reset Talos across the whole cluster
    prompt: Reset the Talos cluster ... continue?
    cmd: talosctl --nodes {{.NODES}} reset --graceful=false
    vars:
      NODES:
        sh: talosctl config info --output json | jq --join-output '[.nodes[]] | join(",")'
    preconditions:
      - talosctl config info
      - talosctl --nodes {{.NODES}} get machineconfig
      - which jq talosctl

  kubeconfig:
    desc: Generate the kubeconfig for a Talos cluster
    cmd: talosctl kubeconfig --nodes {{.RANDOM_CONTROLLER}} --force {{.KUBERNETES_DIR}}
    vars:
      RANDOM_CONTROLLER:
        sh: talosctl config info --output json | jq --raw-output '.endpoints[]' | sort -R | head -1
    preconditions:
      - talosctl config info
      - talosctl --nodes {{.RANDOM_CONTROLLER}} get machineconfig
      - which jq talosctl

  gen-secrets:
    desc: Generate new cluster secrets and update 1Password. Use 'FORCE=true' to overwrite existing secrets.
    cmds:
      - |
        if [ -f {{.ROOT_DIR}}/secrets.yaml ] && [ "{{.FORCE}}" != "true" ]; then
            printf "secrets.yaml already exists. Overwrite? (y/n) "
            read -r reply
            case "$reply" in
                y|Y|yes|YES)
                    ;;
                *)
                    echo "Aborting."
                    exit 1
                    ;;
            esac
        fi
        talosctl gen secrets --force
      - task: update-secrets
        vars:
          OP_VAULT: "{{.OP_VAULT}}"
    preconditions:
      - op user get --me
      - which op talosctl yq

  update-secrets:
    desc: Update 1Password with generated cluster secrets
    cmd: |-
      if [ ! -f {{.ROOT_DIR}}/secrets.yaml ]; then
        echo "Error: secrets.yaml not found. Run 'talosctl gen secrets' first."
        exit 1
      fi

      echo "Updating 1Password with cluster secrets..."

      # Extract values from secrets.yaml
      CLUSTER_ID=$(yq '.cluster.id' {{.ROOT_DIR}}/secrets.yaml)
      CLUSTER_SECRET=$(yq '.cluster.secret' {{.ROOT_DIR}}/secrets.yaml)
      CLUSTER_TOKEN=$(yq '.secrets.bootstraptoken' {{.ROOT_DIR}}/secrets.yaml)
      CLUSTER_SECRETBOXENCRYPTIONSECRET=$(yq '.secrets.secretboxencryptionsecret' {{.ROOT_DIR}}/secrets.yaml)

      # Machine certificates (OS certificates are used for machine API access)
      MACHINE_TOKEN=$(yq '.trustdinfo.token' {{.ROOT_DIR}}/secrets.yaml)
      MACHINE_CA_CRT=$(yq '.certs.os.crt' {{.ROOT_DIR}}/secrets.yaml)
      MACHINE_CA_KEY=$(yq '.certs.os.key' {{.ROOT_DIR}}/secrets.yaml)

      CLUSTER_CA_CRT=$(yq '.certs.k8s.crt' {{.ROOT_DIR}}/secrets.yaml)
      CLUSTER_CA_KEY=$(yq '.certs.k8s.key' {{.ROOT_DIR}}/secrets.yaml)
      CLUSTER_AGGREGATORCA_CRT=$(yq '.certs.k8saggregator.crt' {{.ROOT_DIR}}/secrets.yaml)
      CLUSTER_AGGREGATORCA_KEY=$(yq '.certs.k8saggregator.key' {{.ROOT_DIR}}/secrets.yaml)
      CLUSTER_ETCD_CA_CRT=$(yq '.certs.etcd.crt' {{.ROOT_DIR}}/secrets.yaml)
      CLUSTER_ETCD_CA_KEY=$(yq '.certs.etcd.key' {{.ROOT_DIR}}/secrets.yaml)
      CLUSTER_SERVICEACCOUNT_KEY=$(yq '.certs.k8sserviceaccount.key' {{.ROOT_DIR}}/secrets.yaml)

      # Update 1Password with all secrets
      op item edit "talos" --vault "{{.OP_VAULT}}" \
        "CLUSTER_ID[text]=$CLUSTER_ID" \
        "CLUSTER_SECRET[text]=$CLUSTER_SECRET" \
        "CLUSTER_TOKEN[text]=$CLUSTER_TOKEN" \
        "CLUSTER_SECRETBOXENCRYPTIONSECRET[text]=$CLUSTER_SECRETBOXENCRYPTIONSECRET" \
        "MACHINE_TOKEN[text]=$MACHINE_TOKEN" \
        "MACHINE_CA_CRT[text]=$MACHINE_CA_CRT" \
        "MACHINE_CA_KEY[text]=$MACHINE_CA_KEY" \
        "CLUSTER_CA_CRT[text]=$CLUSTER_CA_CRT" \
        "CLUSTER_CA_KEY[text]=$CLUSTER_CA_KEY" \
        "CLUSTER_AGGREGATORCA_CRT[text]=$CLUSTER_AGGREGATORCA_CRT" \
        "CLUSTER_AGGREGATORCA_KEY[text]=$CLUSTER_AGGREGATORCA_KEY" \
        "CLUSTER_ETCD_CA_CRT[text]=$CLUSTER_ETCD_CA_CRT" \
        "CLUSTER_ETCD_CA_KEY[text]=$CLUSTER_ETCD_CA_KEY" \
        "CLUSTER_SERVICEACCOUNT_KEY[text]=$CLUSTER_SERVICEACCOUNT_KEY"

      echo "Successfully updated 1Password with all cluster secrets"

      # Update external secrets credentials to be properly formatted as a JSON string
      echo "Updating 1Password external secrets credentials..."
      if op item get 1password --field OP_CREDENTIALS_JSON --vault homelab --reveal >/dev/null 2>&1; then
        OP_CREDENTIALS_JSON=$(op item get 1password --field OP_CREDENTIALS_JSON --vault homelab --reveal)
        # Only process if we have valid JSON
        if echo "$OP_CREDENTIALS_JSON" | jq -e . >/dev/null 2>&1; then
          # Escape the JSON properly as a string
          OP_CREDENTIALS_ESCAPED=$(echo "$OP_CREDENTIALS_JSON" | jq -c . | jq -R .)
          op item edit 1password "OP_CREDENTIALS_JSON=$OP_CREDENTIALS_ESCAPED" --vault homelab
          echo "Successfully updated 1Password external secrets credentials"
        else
          echo "Warning: OP_CREDENTIALS_JSON field contains a string, not a JSON object. Assuming it's already escaped."
        fi
      else
        echo "Warning: OP_CREDENTIALS_JSON field not found in 1password item, skipping update"
      fi
    preconditions:
      - op user get --me
      - test -f {{.ROOT_DIR}}/secrets.yaml
      - which op yq jq

  bootstrap:
    desc: Bootstrap Talos controlplane nodes. [NODE=required]
    requires:
      vars: [NODE]
    cmds:
      - talosctl --nodes {{.NODE}} bootstrap
    preconditions:
      - op user get --me
      - talosctl --nodes {{.NODE}} get machineconfig
      - which talosctl
